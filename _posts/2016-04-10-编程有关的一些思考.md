---
layout: post
description: "None.NULL"
tweet-text: ""
author: taocp
tags:
- programming
categories:
- ""
---

今天下午编程时遇到一个“难题”，百思不得其解。经过前辈指点，才恍然大悟。
回想过去的几年，虽然写的代码不多，但类似的情形遇到过好几回！

我想，应该将这些问题分门别类，其实很多问题都可以抽象出一个（或多个）相似的“模式”，
解决这类问题有一个共通的方法。
可以多回顾曾经遇到的问题及其对应的解决方案，总结经验教训。

---

# 用户

确保程序、用户能够精确地互相理解，避免歧义、误解引发错误。

### 给用户精确控制程序的机会

可以人性化一些，尝试为用户做更多的事情，尽管用户没有明确要求。
但一定要考虑用户不需要程序“自作多情”时，能够非常轻易、自然地取消掉这些多余的行为。

例如Python2的`print`默认添加newline或者空格，在大部分场景下是ok的，但部分场景下用户并不需要这个特性，
坑爹的是想避免这样还比较麻烦，要么得加个奇怪的逗号，要么调用其它方法来实现。
还好Python3的`print()`支持设置end参数（不过某些技术被锁死在GCC3和Python2时代的公司，并不能享受到这个福利）

### 如果用户指定的方式不work，则应该明确告知用户

用户指定了条件A，执行时发现A并不work，程序可以尝试从错误中恢复，但必须确保用户清楚发生了什么，
不能在A失败的情况下默默替用户选择B.

曾经遇到这么一个问题：有个程序启动时会读取配置文件，用户可以在init时通过函数参数指定配置文件路径，
如果指定的文件不存在就依次寻找几个预设位置的配置文件。
有一天，用户x通过函数参数指定了配置文件"/path/to/conf.flag"，然而这个路径有误，
程序找不到该文件，于是就在默认路径上找到一个conf文件用了起来（恰巧默认路径上有一个不当的配置文件），结果可想而知。
更好的方法应当是：程序发现用户指定了一个有误的参数，告知用户（返回错误），而不是自作主张。


### 如果做一件事有多种方法，则应当避免歧义

假设一个程序需要读取的配置文件可以由以下途径得到：

- 环境变量
- API参数指定
- 默认位置1
- 默认位置2
- 默认位置...
- 默认位置x

随着用户、运维人员的更迭，可能的局面是“环境变量”、“API参数”、数个“默认位置”都对应这一个配置文件。
当一个新用户面临这种情景，想要弄清当前正在work的是哪个配置文件可能并不容易。

个人感觉最好不要有默认查找行为，“环境变量”高优，API参数次优。
这个规则简单易记，符合convention，环境变量高优也有利于临时调试程序。
当然，如果“环境变量”不是必需，只通过API指定是最好的。

### 知晓所依赖的系统并不完善

使用外部系统时，应当知晓必有其不完善之处，
除非确有必要，尽量避免不成熟、不稳定的feature，
面临特殊场景时，考虑到自己的用法可能触发其bug.

一个支持KV的存储系统T，用户在存数据时存入了一些size巨大的key（具体多大用户自己也不知道！），
系统T默默截断了key至64KB并告知用户存储ok，当用户试图用原始key（size巨大）去读时发现数据读不到。

这样一个事故，存储系统T负有全部责任。
但如果用户考虑得更加周全一些，了解自己的特殊场景并提前和系统T的研发人员沟通，
就可以免去很多本可以不需要的debug开销了。
毕竟类比一下，Linux支持的path最大值默认也就4096 Bytes.


### 不要教用户一些内部命令、带风险的操作

一个系统可能有一些内部命令、带风险的操作(特定场景很有用)，这些都是需要专业人士来操作的。
一旦教给用户，就是打开了潘多拉的盒子。尽管最初会和用户强调各种注意事项，
但只要时间足够长，这些命令、操作在用户之间流传得足够广，一定会有人以各种方式来使用，最终导致问题。

系统自身应该有一定的抵抗能力，但部分情况下权衡利弊之后还是会假定只有懂的人才会执行某些操作，以简化实现。
作为用户，搞点大新闻之前最好能和相关人员了解清楚情况。一言不合就起10w并发执行"自己完全不了解原理的命令"是不是有点冲动。


### 迭代相关的api设计

我发现需要迭代操作时，提供基于`get()/next()`这种形式的api有一个缺点，用户容易忘记调用`next()`。
从api的实现者角度看，好像也没有更好的办法？只能调用者自己注意，尽量从设计上避免忘记`next()`的错误。

可以把`next()`的实现放在`get()`里，但某些场景下可能不够灵活。

---

# 理解现有代码遇到问题

应该先确保正确理解现代码所用的api、工具等

如果是很陌生的api，可能还会仔细查阅手册，减少出错的概率；
但如果看到一个api似乎马上就能理解其意思，但实际行为和用户所理解的不一致，则会导致问题。

遇到过这类问题好几次，我的看法是：

一方面，用户/代码阅读者应该谨慎，如果相应代码表现出异常，则更应该仔细阅读文档；
另一方面，api/代码coder应该保持良好的设计，不要“让用户惊讶”，尽力避免ta人的误解。

---

# general(并没有想出合适的名字)

### 外部依赖

尽量避免不成熟、不可控的依赖，有些依赖看起来有人维护，真出了问题可能没人帮忙解决。

如果不想踩坑排雷，就尽量避免第三方组件的新feature、用得少的功能。(双刃剑)

---

# 防御性编程

### insert/delete操作的预期

很多场景下，对一个数据结构执行insert操作之前，“数据是否可能已经存在”是有预期的，尽可能加个日志。
例如，可以看到假设不存在的数据在insert时已经存在，协助发现问题。delete类似。

---

# 并发&分布式

### 系统仲裁者独立做出决定

很多分布式系统都有一个master，是整个系统的仲裁者，控制着系统内部状态的转换。
当它们做决策时，应当依赖自己的逻辑，不能“轻易相信”外部信息(普适的甄别方法？)。
因为这些外部信息可能是过时、不全面或错误的。

在实际中，观察到某表格系统中这样一个bug。
表格系统master命令某个数据分片服务器(tabletserver)服务某个分片(tablet)完成后，
收到该tabletserver较早对一次query的回复，那次query时，
该tabletserver还没有服务此分片(tablet)，master相信了query的结果，以为该tablet实际无人服务，
于是又尝试命令某个tabletserver去服务，于是这个分片就被2个tabletserver同时服务，最终损坏了数据。

适当的事件&时间戳标记可以防止类似问题的发生。

master如果相信轻易外部信息，不经自己判断就直接做出决策，
那其实系统内就不止1个master，而是多个，因为其它结点可以通过与master的交互“注入代码”。
违背了原本设计master的本意，失去了把控全局的作用。


### 仔细设计系统内部状态

设计系统之初最好仔细想一想哪些状态必须持久化存储，哪些状态没必要，厘清它们之间的组织关系。

依此确定诸如pb协议，这样后续的编码会容易、清晰很多。
不然，需要持久化、不需要持久化的信息互相混杂、散落在各个pb message里，实现起来很复杂。

### 错误和异常只要有可能，就一定会发生

因为各种原因(例如十万火急赶时间，而且出错概率非常小)，尽管一段逻辑可能返回错误或者出现异常(特别是外部系统)，但暂时没有处理。
因为处理这些错误或异常可能需要非常复杂的逻辑，当前去实现性价比很低。

根据我的经验，可以暂时不去实现复杂的容错逻辑，但一定要检查(返回值)，万一不幸遇到错误立即`abort()`或采取其它手段，
**防止错误状态蔓延到整个系统中**，并留下显著线索和信息，以助解决问题。

因为已知这种错误是小概率的，遇到后解决掉重启自己的系统即可。当然这里有个前提是自己的系统必须设计为可以随时重启。


### 长尾问题

如果依赖一个大型的分布式系统，要考虑到很有可能出现的长尾。
架构上最好能减小或消除长尾带来的影响。
另一方面，分布式系统的实现者们最好能尽量避免长尾。复杂～

### 单点故障导致问题的扩散

TODO
(很多时候，分布式基础设施自身在设计上尽量避免了单点故障带来的影响，实际中发现很多应用程序倒是没能避开最后栽了跟头)

---

# API

### 内部实现的精度最好比对外提供的API精度高一个数量级

有一个线程池的实现提供了ms精度的定时任务接口；用户用这个接口实现了1ms一次的定时任务。

不幸的是，线程池内部精度也是ms级的，1us和999us在线程池内部都可能被当作1ms，
于是用户预期的1ms定时任务每过数us就被调度执行一次，比设想的情况快了数十、数百倍。

当然，具体情况具体分析，不同场景对误差的容忍不一样；实现代价也是一个重要因素。

[bug](https://github.com/baidu/tera/pull/972)

---

# 新技术、新知识

在用新(陌生)技术解决问题、实际应用之前，应当对新东西有一个宏观的、整体的认识。

如果有好的tutorial，不妨跟着做一做，会有更直观的理解；
如果有自动生成的代码，也要弄清生成的代码（模块、文件）的作用，如果可以大致看看代码是怎样的。

---

# 一些有趣的特性

### 运行时reload config

对于很多需要7 x 24运行的服务来说，能够支持在运行时更新配置文件是一个很必须的功能；
特别是有些问题（例如bug）在程序重启后可能不再复现，如果此时支持运行时reload config，
可能有益于发现问题（例如调整日志打印级别，更改特定参数等）。

程序设计时就要考虑到动态地reload config，具体问题具体分析吧。

见过有程序把一些属性放在某个特定namespace里，然后gdb上去直接改内存的。


---

# 打log的一些经验

TODO


---

# 一些决策有关的思考

### 是否要（参与）开发一个新项目

这方面经验非常少，根据非常有限的观察，总结出的结论是：
除了眼前的收益，还要考虑到项目后续的发展、维护。
否则花几个月搞定的项目，短期内有收益是资产；长远看可能就是负债了。
