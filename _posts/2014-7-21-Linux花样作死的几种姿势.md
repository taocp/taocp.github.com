---
layout: post
description: "None.NULL"
tweet-text: ""
author: taocp
tags:
- linux
categories:
- linux
---

**no zuo no die why you try?**

**no try no high give me five.**

**let it go**

记录一些可以把系统整崩溃的方法，纯属闲得蛋疼。持续更新中。

**FBI warning** ：严肃提示，内含危险操作，请勿随意模仿，否则后果自负。

# rm /
那些张口就是`# rm -rf /`的小盆友，你们真的以为这样就可以达到目的了？

既不好好看书，又没自己实践一下，道听途说，以讹传讹，真为你们感到着急。

正确的姿势`# rm -rf --no-preserve-root /`

[一篇有趣的文章，下次试一试](http://blog.jobbole.com/70971/)


# gdb调试X
`# gdb foo $(ps aux|grep bin/X | awk 'NR==1 {print $2}')`


其中`$(ps aux|grep bin/X | awk 'NR==1 {print $2}')`的作用是取`X`的PID.

`gdb foo PID`是命令gdb`attach`到进程号为PID的进程上。

根据gdb的工作原理，attach成功后`/usr/bin/X`就会被gdb控制，`X`会停下来等待gdb的操作，

而此时已经没办法给gdb输入命令了，因为`X`已经被gdb冻结了，死锁。

此时宏观上来看，执行完上面的命令后，整个系统就"失去"了响应。

解法一：

从`X`入手：从tty控制台执行上述命令，等gdb停下来后`<C-D>`退出，不会死锁。因为tty控制台不依赖`X`.

注意：在tty控制台下attach到`X`后不要切换到`<F7>`(X)那里，否则也会死锁。

猜测原因如下：
在tty里，一旦按下`<Ctrl-Alt-F7>`，就会调用`X`，
然后由于不知道什么原因（暂未查证），`X`会收到某种信号导致其停下来等待gdb的控制，
此时应该是已经切换到了`X`界面但还没来得及刷新桌面（所以还是tty的样子）就被停下了，
所以没办法进行输入，导致死锁。

以上纯属猜测，求真相。

解法二：

从gdb入手： 埋好炸弹，定时kill掉gdb，结束死锁。

例如先执行`# sleep 10; killall gdb`，可以看到系统先冻结几秒钟，等待gdb被kill掉后死锁解开，系统恢复正常。


# fork炸弹
[fork炸弹(wiki)](https://zh.wikipedia.org/zh/Fork炸弹)解释很详细。

