---
layout: post
description: "None.NULL"
tweet-text: ""
author: taocp
tags:
- linux
categories:
- linux
---

**no zuo no die why you try?**

**no try no high give me five.**

**let it go**

记录一些可以把系统整崩溃的方法，纯属闲得蛋疼。持续更新中。

**FBI warning** ：严肃提示，内含危险操作，请勿随意模仿，否则后果自负。

# rm系列
那些张口就是`# rm -rf /`的小盆友，你们真的以为这样就可以达到目的了？

既不好好看书，又没自己实践一下，道听途说，以讹传讹，真为你们感到着急。

正确的姿势`# rm -rf --no-preserve-root /`

[一篇有趣的文章，下次试一试](http://blog.jobbole.com/70971/)


# X系列
`# gdb foo $(ps aux|grep bin/X | awk 'NR==1 {print $2}')`


`$(ps aux|grep bin/X | awk 'NR==1 {print $2}')`的作用是取`X`的PID.

`gdb foo PID`是命令gdb`attach`到pid=PID的进程上。

根据gdb的工作原理，attach成功后`/usr/bin/X`就会被gdb控制，`X`会停下来等待gdb的操作，

而此时已经没办法给gdb输入命令了，因为`X`已经被gdb冻结了，死锁。

此时宏观上来看，执行完上面的命令后，整个系统就"失去"了响应。

解法一：

从`X`入手：从tty控制台执行上述命令，等gdb停下来后`<C-D>`退出，不会死锁。因为tty控制台不依赖`X`.

不过这里我还有一点疑问，在tty里执行该命令后不能让gdb执行`continue`，否则也会死锁，这是怎么回事呢？

照理讲，没有任何断点的时候，`continue`应该保证`X`一路畅通无阻的执行，也就不会死锁才对？求指教。

解法二：

从gdb入手： 埋好炸弹，定时kill掉gdb，结束死锁。 

例如先执行`# sudo sleep 10; sudo killall gdb`，可以看到系统先冻结几秒钟，等待gdb被kill掉后不再死锁，系统恢复正常。



