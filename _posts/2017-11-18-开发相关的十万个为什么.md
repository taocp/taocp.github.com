---
layout: post
description: "None.NULL"
tweet-text: ""
author: taocp
tags:
- programming
categories:
- ""
---


平时工作学习，常常遇到一些“小问题”，有很多办法可以绕开或者“解决”，有空的时候稍微深入查阅资料了解其中的原因也蛮有意思。


## Text file busy

假设可执行程序`a.out`使用了`x.so`，在`a.out`运行时，`cp a.out.new a.out`会报`Text file busy`，
`cp x.v2.so x.so`可能导致进程crash，在替换可执行文件或者动态库时，如果是先`rm`再`cp`（而不是直接`cp`覆盖）又都是ok的，为什么？

  - `rm`后再`cp`是删除旧文件（Linux保证已经打开旧文件的进程仍然能看到旧文件，这些进程都关闭旧文件时发生真正的删除）再写一个新文件（inode变了），`cp src des`是在原文件上写入新内容（inode没变）。
  - 运行时`cp a.out.new a.out`是尝试打开`a.out`写入`a.out.new`的内容，`open()`的时候Linux检测到这个二进制程序正在运行，所以返回`ETXTBSY(Text file busy)`错误。
  - 运行时`cp x.v2.so x.so`是尝试打开`x.so`写入`x.v2.so`的内容，但（截至目前2017.11）并没有针对so的“写保护”，所以覆盖写操作本身ok，不过so一般都是`mmap`到内存的，可能不是整个so文件都已在内存（按需），
    如果运行过程中替换了so，下次再访问so内容时按照旧so的各种偏移来访问新so文件就会crash.
  - [ref1](https://unix.stackexchange.com/a/74172/73846), [ref2](https://stackoverflow.com/a/7779703/1498303)


## nohup

在shell里后台执行一个任务(形如`./a.out &`)，关闭终端时，shell可能会给后台进程传送一个`SIGHUP`的信号，默认情况下收到这个信号进程就退出了。
所以，如果是简单的`a.out &`后台执行一个程序，可能不小心退出终端（毕竟高兴的时候一口气N个`exit`根本停不下来）或者断网就会导致任务中断。

原因清楚以后，要解决这个问题就有好几种办法了。

- 配置一下，使得shell收到`SIGHUP`以后，不再发送给它的子进程。例如bash可以通过`shopt -s huponexit`和`shopt -u huponexit`来控制，`shopt huponexit`获取当前配置。我遇到的好些Linux环境，bash默认都是`huponexit off`的，也就是默认情况下退出终端不会kill掉后台进程。

- GNU的`nohup`工具，它在`coreutils`（GNU core utilities）里，看看源码就会发现原理挺直白的，先`signal (SIGHUP, SIG_IGN);`然后`exec()`从而忽略掉`SIGHUP`。

- [signal-wiki](https://en.wikipedia.org/wiki/Signal_(IPC)), [sighup-wiki](https://en.wikipedia.org/wiki/SIGHUP), [ref3](https://serverfault.com/a/117157/294205), [ref4](https://stackoverflow.com/a/4319666/1498303), nohup-src


## 编码问题

(TODO)

<!-- 原理说明；实验：终端编码、vim编码配置、文件编码 -->


- [unicode at joelonsoftware]( https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses)
- [unicode in python](http://farmdev.com/talks/unicode/)